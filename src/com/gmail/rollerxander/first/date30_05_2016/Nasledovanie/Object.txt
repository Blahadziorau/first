Класс Object
На вершине иерархии классов находится класс Object, который является суперклассом для всех классов. Ссылочная переменная типа Object может ука-зывать на объект любого другого класса, на любой массив, так как массивы реа-лизуются как классы. В классе Object определен набор методов, который наследуется всеми классами:
protected Object clone() – создает и возвращает копию вызывающе-го объекта;
boolean equals(Object ob) – предназначен для переопределения в подклассах с выполнением общих соглашений о сравнении содержимого двух объектов;
Class<? extends Object> getClass() – возвращает объект типа Class;
protected void finalize() – вызывается перед уничтожением объек-та автоматическим сборщиком мусора (garbage collection);
int hashCode() – возвращает хэш-код объекта;
String toString() – возвращает представление объекта в виде строки.
Методы notify(), notifyAll() и wait() будут рассмотрены в главе «Потоки выполнения».
Если при создании класса предполагается проверка логической эквива-лентности объектов, которая не выполнена в суперклассе, следует переопределить два метода: equals(Object ob) и hashCode(). Кроме того, переопределение этих методов необходимо, если логика приложения предусматривает исполь-зование элементов в коллекциях. Метод equals() при сравнении двух объектов возвращает истину, если содержимое объектов эквивалентно, и ложь – в против-ном случае. При переопределении метода equals() должны выполняться со-глашения, предусмотренные спецификацией языка Java, а именно:
 рефлексивность – объект равен самому себе;
 симметричность – если x.equals(y) возвращает значение true, то и y.equals(x) всегда возвращает значение true;
 транзитивность – если метод equals() возвращает значение true при сравнении объектов x и y, а также y и z, то и при сравнении x и z будет возвращено значение true;
 непротиворечивость – при многократном вызове метода для двух не подвергшихся изменению за это время объектов возвращаемое значе-ние всегда должно быть одинаковым;
 ненулевая ссылка при сравнении с литералом null всегда возвращает значение false.
При создании информационных классов также рекомендуется переопределять методы hashCode() и toString(), чтобы адаптировать их действия для со-здаваемого типа.
Метод hashCode() переопределен, как правило, в каждом классе и воз-вращает число, являющееся уникальным идентификатором объекта, зависящим в большинстве случаев только от значения объекта. Его следует переопределять всегда, когда переопределен метод equals(). Метод hashCode() возвращает хэш-код объекта, вычисление которого управляется следующими соглашениями:
 во время работы приложения значение хэш-кода объекта не изменяется, если объект не был изменен;
 все одинаковые по содержанию объекты одного типа должны иметь одинаковые хэш-коды;
 различные по содержанию объекты одного типа могут иметь различ-ные хэш-коды.
Один из способов создания правильного метода hashCode(), гарантирую-щий выполнение соглашений, приведен ниже, в примере # 10.
Метод toString() следует переопределять таким образом, чтобы кроме стандартной информации о пакете (опционально), в котором находится класс, и самого имени класса (опционально), он возвращал значения полей объекта, вы-звавшего этот метод (то есть всю полезную информацию объекта), вместо хэш-кода, как это делается в классе Object. Метод toString() класса Object возвращает строку с описанием объекта в виде:
getClass().getName() + '@' +
Integer.toHexString(hashCode())
Метод вызывается автоматически, когда объект выводится методами println(), print() и некоторыми другими. /* пример # 10 : переопределение методов equals(), hashCode, toString(): 
Student.java */ 

package chapt04;
public class Student { 
	private int id;
	private String name; 
	private int age;
	
	public Student(int id, String name, int age){ 
		this.id = id; 
		this.name = name; 
		this.age = age; 
	} 
	public int getId() { 
		return id; 
	} 
	public String getName() { 
		return name; 
	} 
	public int getAge() { 
		return age; 
	} 
	public boolean equals(Object obj) { 
		if (this == obj) return true;
		if (obj == null) return false; 
		if (obj instanceof Student){ 
			//warning Student 
			temp = (Student) obj; 
			return this.id == temp.id && name.equals(temp.name) && this.age == temp.age; 
		} else return false; 
	} 
	
	public int hashCode() { 
		return (int)(31 * id + age + ((name == null) ? 0 : name.hashCode())); 
	} 
	
	public String toString() { 
		return getClass().getName() + "@name" + name + " id:" + id + " age:" + age; 
	} 
}

Выражение 31 * id + age гарантирует различные результаты вычисле-ний при перемене местами значений полей, а именно если id=1 и age=2, то в результате будет получено 33, если значения поменять местами, то 63. Такой подход применяется при наличии у классов полей базовых типов.
Метод equals() переопределяется для класса Student таким образом, чтобы убедиться в том, что полученный объект является объектом типа Student или одним из его наследников, а также сравнить содержимое полей id, name и age соответственно у вызывающего метод объекта и объекта, передаваемого в качестве параметра.